import { createStep, createWorkflow } from "@mastra/core";
import z from "zod";
import { tweetAgent } from "../agents/tweet-agent";
import { asyncWrapProviders } from "async_hooks";
import { appendFile } from "fs";

const generateTweet = createStep({
  id: "generateTweet",
  description: "Generate a tweet",
  inputSchema: z.object({ prompt: z.string() }),
  resumeSchema: z.object({
    approved: z.boolean().optional()
  }),
  suspendSchema: z.object({
    prompt: z.string()
  }),
  outputSchema: z.object({
    tweet: z.string().nullable(),
    approved: z.boolean()
  }),
  execute: async ({ inputData, suspend, resumeData, getStepResult }) => {
    console.log("previous output", getStepResult({id: "generateTweet"} as any))
    console.log("inputData", inputData)
    console.log("resumeData", resumeData)

    if (resumeData?.approved) {
      // how do I access the X post copy generated by
      // the previously-executed instance of this step? 
      return { tweet: inputData.prompt, approved: true };
    }

    const { text } = await tweetAgent.generate(inputData.prompt, {
      temperature: 1.2,
      topP: 0.9,
    });

    console.log("text", text);

    await suspend({prompt: text});

    // this outputSchema is only referenced  by dountil
    // thus, the tweet is irrelevant (not needed), pass null
    return { tweet: text, approved: false };
  },
});

const stepOne = createStep({
  id: "stepOne",
  description: "Step one",
  inputSchema: z.object({ tweet: z.string() }),
  outputSchema: z.object({ tweet: z.string() }),
  execute: async ({ inputData, suspend }) => {
    console.log("inputData", inputData)
    const { text } = await tweetAgent.generate(inputData.tweet, {
      temperature: 1.2,
      topP: 0.9,
    });

    console.log("text", text);

    // await suspend({prompt: text});

    // this outputSchema is only referenced  by dountil
    // thus, the tweet is irrelevant (not needed), pass null
    return { tweet: text, approved: false };
  },
});

const stepTwo = createStep({
  id: "stepTwo",
  description: "Step two",
  inputSchema: z.object({ tweet: z.string() }),
  resumeSchema: z.object({
    approved: z.boolean().optional()
  }),
  outputSchema: z.object({ tweet: z.string(), approved: z.boolean() }),
  execute: async ({ inputData, resumeData, suspend }) => {
    console.log("inputData", inputData)
    if (resumeData?.approved) {
      return { tweet: inputData.tweet, approved: true };
    }

    return suspend({})
  },
})

const tweetWorkflow = createWorkflow({
  id: "tweet-workflow",
  inputSchema: z.object({ tweet: z.string() }),
  outputSchema: z.object({
    tweet: z.string().nullable(),
    approved: z.boolean()
  }),
})
.then(stepOne)
.then(stepTwo)
.commit();

export const tbdWorkflow = createWorkflow({
  id: "tbd-workflow",
  inputSchema: z.object({ tweet: z.string() }),
  outputSchema: z.object({ tweet: z.string() }),
})
// create 2 steps
// replace with workflow = generate tweet, step 2 ask
// TODO rename tweet to prompt and use map
  .dountil(tweetWorkflow, async ({ inputData }) => inputData.approved)
  .commit();
